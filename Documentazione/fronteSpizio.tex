\documentclass[a4paper]{article}
\usepackage{amsfonts,amssymb,amstext,amsmath,amsthm,verbatim,times,cancel,epsfig} 
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel} 
\usepackage{setspace}
\usepackage{hyperref}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage{xcolor}
\definecolor{RoyalBlue}{cmyk}{1, 0.50, 0, 0}
\hypersetup{
    colorlinks=true, %set true if you want colored links
    linktoc=all,     %set to all if you want both sections and subsections linked
    linkcolor=black,  %choose some color if you want links to stand out
}
\lstset{language=C,
    keywordstyle=\color{RoyalBlue},
    basicstyle=\scriptsize\ttfamily,
    commentstyle=\ttfamily\itshape\color{gray},
    stringstyle=\ttfamily,
    showstringspaces=false,
    breaklines=true,
    frameround=ffff,
    frame=single,
    rulecolor=\color{black},
    numbers = left
}

\begin{document} 
\begin{titlepage}

\begin{center}
    {\bfseries\Huge Università degli Studi di Napoli\\}
\end{center} 

\begin{figure}[h]
    \begin{center}
        
\includegraphics[width=0.25\textwidth]{fiilogo.png}    %inserire nella stessa cartella del tex il logo dell'università e inserire il nome al posto di logo.jpg
    \end{center}
\end{figure}
  
\begin{center}
    \bf{Scuola Politecnica e delle Scienze di Base}
\end{center}
\begin{center}
    \bf{Area Didattica di Scienze Matematiche Fisiche e Naturali}
\end{center}
\vspace{5pt}
\begin{center}
    \textbf{Dipartimento di Ingegneria Elettrica e delle Tecnologie dell'Informazione}
\end{center}
\vspace{40pt}
\begin{center}
    {\emph{\Large{\bf{Progetto sistemi operativi}}}}\\
    
\end{center}
\vspace{15pt}


\begin{center}
    {{ \textit{Traccia A}}}
\end{center}
\vspace{25mm}
\par
\noindent
\begin{minipage}[t]{0.47\textwidth}
    \textbf{Professore:}\\
    Alberto Finzi\\   
\end{minipage}
\hfill
\begin{minipage}[t]{0.47\textwidth}\raggedleft
    \textbf{Candidati:}\\
    Mario Turco\\ 
    Matr. $N860002503$\\
    Francesco Longobardi\\
    Matr.  $N860002468$\\
\end{minipage}
\vspace{5.5mm}
\begin{center}
    {\large{\bf Anno Accademico 2019/2020}} 
\end{center}
\end{titlepage}

\thispagestyle{empty}\null\newpage
\tableofcontents
\newpage
\pagenumbering{arabic}
\section{Istruzioni preliminari}
\subsection{Modalità di compilazione}
\paragraph{}
Il progetto è provvisto di un file makefile il quale è in grado di compilare autonomamente l'intero progetto.
Per utilizzare il makefile aprire la cartella del progetto tramite la console di sistema e digitare "make".\\
In alternativa è possibile compilare manualemente il client ed il server con i seguenti comandi:
\begin{Verbatim}[fontsize=\small]
    gcc -o server server.c boardUtility.c parser.c list.c -lpthread
    gcc -o client client.c boardUtility.c parser.c list.c -lpthread
\end{Verbatim}
\section{Guida all'uso }
\subsection{Server}
\paragraph{}
Una volta compilato il progetto è possibile avviare il server digitando da console il seguente comando
\begin{verbatim}
    ./server users
\end{verbatim}
L'identificativo \textit{users} ri riferisce al nome del file sul quale sarà salvata la lista degli utenti e delle loro credenziali.\\
È possibile scegliere un nome a piacimento per il file purchè esso sia diverso da \textit{log}.
\subsection{Client}
\paragraph{}
Una volta compilato il progetto è possibile avviare il cient digitando da console il seguente comando:
\begin{verbatim}
    ./client ip porta
\end{verbatim}
Dove \textit{ip} andrà sostituito con l'ip o l'indirizzo URL del server e \textit{porta} andrà sostituito con la porta del server.\\
Una volta avviato il client comprarià il menu con le scelte 3 possibili: accedi, registrati ed esci.\\
Una volta effettuata la registrazione dell'utente è possibile effettuare l'accesso al programma al seguito del quale verranno mostrate sia la mappa dei gioco si le istruzioni di gioco.
\pagebreak
\section{Comunicazione tra client e server}
Di seguito verranno illustrate le modalità di comunicazione tra client e server.
\subsection{Configurazione del server}
Il socket del server viene configurato con famiglia di protoccoli PF\_NET, con tipo di trasmissione dati SOCK\_STREAM e con protocollo TCP. Mostriamo di seguito il codice sorgente:
\begin{lstlisting}
void configuraSocket(struct sockaddr_in mio_indirizzo) {
  if ((socketDesc = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
    perror("Impossibile creare socket");
    exit(-1);
  }
  if (setsockopt(socketDesc, SOL_SOCKET, SO_REUSEADDR, &(int){1}, sizeof(int)) < 0)
    perror("Impossibile impostare il riutilizzo dell'indirizzo ip e della "
           "porta\n");
  if ((bind(socketDesc, (struct sockaddr *)&mio_indirizzo,
            sizeof(mio_indirizzo))) < 0) {
    perror("Impossibile effettuare bind");
    exit(-1);
  }
}
\end{lstlisting}
È importante notare anche come il server riesca a gestire in modo concorrente più client tramite l'uso di un thread dedicato ad ogni client. 
Una volta aver configurato il socket, infatti,  il server si mette in ascolto per nuove connessioni in entrata ed ogni volta che
viene stabilita una nuova connessione viene avviato un thread per gestire tale connessione. Di seguito il relativo codice: 
\begin{lstlisting}
void startListening()
{
    pthread_t tid;
    int clientDesc;
    int *puntClientDesc;
    while (1)
    {
      if (listen(socketDesc, 10) < 0)
        perror("Impossibile mettersi in ascolto"), exit(-1);
      printf("In ascolto..\n");
      if ((clientDesc = accept(socketDesc, NULL, NULL)) < 0)
      {
        perror("Impossibile effettuare connessione\n");
        exit(-1);
      }
      printf("Nuovo client connesso\n");
      puntClientDesc = (int *)malloc(sizeof(int));
      *puntClientDesc = clientDesc;
      pthread_create(&tid, NULL, gestisci, (void *)puntClientDesc);
    }
    close(clientDesc);
    quitServer();
}
\end{lstlisting}
In particolare al rigo 19 notiamo la creazione di un nuovo thread per gestire la connessione in entrata a cui passiamo il descrittore del client di cui si deve occupare.
\pagebreak
\subsection{Configurazione del client}
Il cliente invece viene configurato e si connette al server tramite la seguente funzione:
\begin{lstlisting}
int connettiAlServer(char **argv) {
    char *indirizzoServer;
    uint16_t porta = strtoul(argv[2], NULL, 10);
    indirizzoServer = ipResolver(argv);
    struct sockaddr_in mio_indirizzo;
    mio_indirizzo.sin_family = AF_INET;
    mio_indirizzo.sin_port = htons(porta);
    inet_aton(indirizzoServer, &mio_indirizzo.sin_addr);
    if ((socketDesc = socket(PF_INET, SOCK_STREAM, 0)) < 0)
      perror("Impossibile creare socket"), exit(-1);
    else
      printf("Socket creato\n");
    if (connect(socketDesc, (struct sockaddr *)&mio_indirizzo,
                sizeof(mio_indirizzo)) < 0)
      perror("Impossibile connettersi"), exit(-1);
    else
      printf("Connesso a %s\n", indirizzoServer);
    return socketDesc;
  }
\end{lstlisting}
Si noti come al rigo 9 viene configurato il socket ed al rigo 13 viene invece effettuato il tentativo di connessione al server.\\
Al rigo 3 invece viene convertita la porta inserita in input (argv$[$2$]$) dal tipo stringa al tipo della porta (uint16\_t ovvero unsigned long integer).\\
Al rigo 4 notiamo invece la risoluzione dell'url da parte della funzione ipResolver che è riportata di seguito:
\begin{lstlisting}
char *ipResolver(char **argv) {
    char *ipAddress;
    struct hostent *hp;
    hp = gethostbyname(argv[1]);
    if (!hp) {
            perror("Impossibile risolvere l'indirizzo ip\n");
            sleep(1);
            exit(-1);
        }
    printf("Address:\t%s\n", inet_ntoa(*(struct in_addr *)hp->h_addr_list[0]));
    return inet_ntoa(*(struct in_addr *)hp->h_addr_list[0]);
}
\end{lstlisting}
Al rigo 4, tramite l'url o l'indirizzo ip viene riempita la struttura hostent da cui poi possiamo estrarre l'indirizzo ip presente nel campo 
h\_addr\_list  che, in effetti, è un array che contiene i vari indirizzi ip associati a quell'host.\\
Infine, al rigo 11 decidiamo di ritoranre soltanto il primo indirizzo convertito in ascii.
\end{document}