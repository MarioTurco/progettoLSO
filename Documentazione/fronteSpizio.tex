\documentclass[a4paper]{article}
\usepackage{amsfonts,amssymb,amstext,amsmath,amsthm,verbatim,times,cancel,epsfig} 
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel} 
\usepackage{setspace}
\usepackage{hyperref}
\usepackage{fancyvrb}
\usepackage{multicol}
\usepackage{listings}
\usepackage{xcolor}
\definecolor{RoyalBlue}{cmyk}{1, 0.50, 0, 0}
\hypersetup{
    colorlinks=true, %set true if you want colored links
    linktoc=all,     %set to all if you want both sections and subsections linked
    linkcolor=black,  %choose some color if you want links to stand out
}
\lstset{language=C,
    keywordstyle=\color{RoyalBlue},
    basicstyle=\scriptsize\ttfamily,
    commentstyle=\ttfamily\itshape\color{gray},
    stringstyle=\ttfamily,
    showstringspaces=false,
    breaklines=true,
    frameround=ffff,
    frame=single,
    rulecolor=\color{black},
    numbers = left
}
\renewcommand\lstlistlistingname{Listati}
\renewcommand\lstlistingname{Listato}
\def\lstlistingautorefname{List.}

\begin{document} 
\begin{titlepage}
  \pagestyle{empty}
  \begin{center}
  
  % TO EDIT ACCORDINGLY TO...
  % -----------------------------------------------------------------------------------------------
  %
  
  % ... University Name
  {\bfseries\Huge Università degli Studi di Napoli\\}
  \vspace{2.54mm}
  {\bfseries\Huge Federico II\\}
  \vspace{5mm}
  
  % ... Logo
  \centerline{\mbox{\includegraphics[width=36mm]{fiilogo.png}}}
  
  % ... Departement
  \medskip
  {\bfseries\LARGE Dipartimento di Ingegneria Elettrica e\\}
  \vspace{2.54mm}
  {\bfseries\LARGE delle Tecnologie dell'Informazione\\}
  \vspace{5mm}
  
 
  
  % ... Degree Course
  {\large Corso di Laurea Triennale in Informatica\\}
  \vspace{2.5mm}
   % ... Degree Class
   {\emph{\large Classe n. L-31\\}}
   \vspace{2.54mm}
  % Change the name of Departement, Class and Cource in English?
  
  %
  % -----------------------------------------------------------------------------------------------
  %
  
  \vfill
  {\emph{\LARGE Progetto di sistemi operativi\\}}		% Thesis title
  \vspace{4mm}
  {\Large Traccia A\\}
  \vspace{4mm}
  
  \vfill
  
  \begin{multicols}{2}
    {\large Professore:\\}
    Finzi Alberto\
    \vspace{5mm}
    
    
      \vspace{5mm}
    
    {\large Candidati:\\}
    Turco Mario\\
    Matr. N8600/2503\\
    Longobardi Francesco\\
    Matr. N8600/2468\\
    \vspace{10mm}
  \end{multicols}
  
  \vfill
  
  % Fill the year
  {\large Anno Accademico\\ 2019/2020}
  
  \end{center}
  

\end{titlepage}

\tableofcontents
\clearpage\null\newpage

\pagenumbering{arabic}
\section{Istruzioni preliminari}
\subsection{Modalità di compilazione}
\paragraph{}
Il progetto è provvisto di un file makefile il quale è in grado di compilare autonomamente l'intero progetto.
Per utilizzare il makefile aprire la cartella del progetto tramite la console di sistema e digitare "make".\\
In alternativa è possibile compilare manualemente il client ed il server con i seguenti comandi:
\begin{Verbatim}[fontsize=\small]
    gcc -o server server.c boardUtility.c parser.c list.c -lpthread
    gcc -o client client.c boardUtility.c parser.c list.c -lpthread
\end{Verbatim}
\section{Guida all'uso }
\subsection{Server}
\paragraph{}
Una volta compilato il progetto è possibile avviare il server digitando da console il seguente comando
\begin{verbatim}
    ./server users
\end{verbatim}
L'identificativo \textit{users} ri riferisce al nome del file sul quale sarà salvata la lista degli utenti e delle loro credenziali.\\
È possibile scegliere un nome a piacimento per il file purchè esso sia diverso da \textit{log}.
\subsection{Client}
\paragraph{}
Una volta compilato il progetto è possibile avviare il cient digitando da console il seguente comando:
\begin{verbatim}
    ./client ip porta
\end{verbatim}
Dove \textit{ip} andrà sostituito con l'ip o l'indirizzo URL del server e \textit{porta} andrà sostituito con la porta del server.\\
Una volta avviato il client comprarià il menu con le scelte 3 possibili: accedi, registrati ed esci.\\
Una volta effettuata la registrazione dell'utente è possibile effettuare l'accesso al programma al seguito del quale verranno mostrate sia la mappa dei gioco si le istruzioni di gioco.
\pagebreak
\section{Comunicazione tra client e server}
Di seguito verranno illustrate le modalità di comunicazione tra client e server.
\subsection{Configurazione del server}
Il socket del server viene configurato con famiglia di protoccoli PF\_NET, con tipo di trasmissione dati SOCK\_STREAM e con protocollo TCP. Mostriamo di seguito il codice sorgente:
\begin{lstlisting}[caption={Configurazione socket del server}]
void configuraSocket(struct sockaddr_in mio_indirizzo) {
  if ((socketDesc = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
    perror("Impossibile creare socket");
    exit(-1);
  }
  if (setsockopt(socketDesc, SOL_SOCKET, SO_REUSEADDR, &(int){1}, sizeof(int)) < 0)
    perror("Impossibile impostare il riutilizzo dell'indirizzo ip e della "
           "porta\n");
  if ((bind(socketDesc, (struct sockaddr *)&mio_indirizzo,
            sizeof(mio_indirizzo))) < 0) {
    perror("Impossibile effettuare bind");
    exit(-1);
  }
}
\end{lstlisting}
È importante notare anche come il server riesca a gestire in modo concorrente più client tramite l'uso di un thread dedicato ad ogni client. 
Una volta aver configurato il socket, infatti,  il server si mette in ascolto per nuove connessioni in entrata ed ogni volta che
viene stabilita una nuova connessione viene avviato un thread per gestire tale connessione. Di seguito il relativo codice: 
\begin{lstlisting}[caption={Procedura di ascolto del server}]
void startListening()
{
    pthread_t tid;
    int clientDesc;
    int *puntClientDesc;
    while (1)
    {
      if (listen(socketDesc, 10) < 0)
        perror("Impossibile mettersi in ascolto"), exit(-1);
      printf("In ascolto..\n");
      if ((clientDesc = accept(socketDesc, NULL, NULL)) < 0)
      {
        perror("Impossibile effettuare connessione\n");
        exit(-1);
      }
      printf("Nuovo client connesso\n");
      puntClientDesc = (int *)malloc(sizeof(int));
      *puntClientDesc = clientDesc;
      pthread_create(&tid, NULL, gestisci, (void *)puntClientDesc);
    }
    close(clientDesc);
    quitServer();
}
\end{lstlisting}
In particolare al rigo 19 notiamo la creazione di un nuovo thread per gestire la connessione in entrata a cui passiamo il descrittore del client di cui si deve occupare.
\pagebreak
\subsection{Configurazione del client}
Il cliente invece viene configurato e si connette al server tramite la seguente funzione:
\begin{lstlisting}[caption={Configurazione e connessione del client}]
int connettiAlServer(char **argv) {
    char *indirizzoServer;
    uint16_t porta = strtoul(argv[2], NULL, 10);
    indirizzoServer = ipResolver(argv);
    struct sockaddr_in mio_indirizzo;
    mio_indirizzo.sin_family = AF_INET;
    mio_indirizzo.sin_port = htons(porta);
    inet_aton(indirizzoServer, &mio_indirizzo.sin_addr);
    if ((socketDesc = socket(PF_INET, SOCK_STREAM, 0)) < 0)
      perror("Impossibile creare socket"), exit(-1);
    else
      printf("Socket creato\n");
    if (connect(socketDesc, (struct sockaddr *)&mio_indirizzo,
                sizeof(mio_indirizzo)) < 0)
      perror("Impossibile connettersi"), exit(-1);
    else
      printf("Connesso a %s\n", indirizzoServer);
    return socketDesc;
  }
\end{lstlisting}
Si noti come al rigo 9 viene configurato il socket ed al rigo 13 viene invece effettuato il tentativo di connessione al server.\\
Al rigo 3 invece viene convertita la porta inserita in input (argv$[$2$]$) dal tipo stringa al tipo della porta (uint16\_t ovvero unsigned long integer).\\
Al rigo 4 notiamo invece la risoluzione dell'url da parte della funzione ipResolver che è riportata di seguito:
\begin{lstlisting}[caption={Risoluzione url del client}]
char *ipResolver(char **argv) {
    char *ipAddress;
    struct hostent *hp;
    hp = gethostbyname(argv[1]);
    if (!hp) {
            perror("Impossibile risolvere l'indirizzo ip\n");
            sleep(1);
            exit(-1);
        }
    printf("Address:\t%s\n", inet_ntoa(*(struct in_addr *)hp->h_addr_list[0]));
    return inet_ntoa(*(struct in_addr *)hp->h_addr_list[0]);
}
\end{lstlisting}
Al rigo 4, tramite l'url o l'indirizzo ip viene riempita la struttura hostent da cui poi possiamo estrarre l'indirizzo ip presente nel campo 
h\_addr\_list  che, in effetti, è un array che contiene i vari indirizzi ip associati a quell'host.\\
Infine, al rigo 11 decidiamo di ritoranre soltanto il primo indirizzo convertito in ascii.
\pagebreak
\subsection{Comunicazione tra client e server}
La comunicazione tra client e server avviene tramite write e read sul socket.\\
Il comportamento del server e del client è determinato da particolari messaggi inviati e/o ricevuti che codificano, tramite interi o caratteri, la richiesta da parte del client di usufruire di un determinato servizio e la relativa risposta del server.
 \subsubsection{Esempio: la prima comunicazione}
 In particolare, una volta effettuata la connessione,
il server attenderà un messaggio dal client per poter avviare una delle tre possibili procedure, ovvero login, registrazione ed uscita ( rispettivamente codici: 1,2,3).\\
Di seguito sono riportate le realtive funzioni di gestione che entrano in esecuzione subito dopo aver stabilito la connessione
tra client e server.
\begin{lstlisting}[caption=Prima comunicazione del server, label=alg:serverPreLogin]
  void *gestisci(void *descriptor) {
    int bufferReceive[2] = {1};
    int client_sd = *(int *)descriptor;
    int continua = 1;
    char name[MAX_BUF];
    while (continua) {
      read(client_sd, bufferReceive, sizeof(bufferReceive));
      if (bufferReceive[0] == 2)
        registraClient(client_sd);
      else if (bufferReceive[0] == 1)
        if (tryLogin(client_sd, name)) {
          play(client_sd, name);
          continua = 0;
        } else if (bufferReceive[0] == 3)
          disconnettiClient(client_sd);
        else {
          printf("Input invalido, uscita...\n");
          disconnettiClient(client_sd);
        }
    }
    pthread_exit(0);
  }
\end{lstlisting}
Si noti come il server riceva, al rigo 7, il messaggio codificato da parte del client e metta in esecuzione la funzione corrispondente.
\begin{lstlisting}[caption=Prima comunicazione del client, label=alg:clientPreLogin]
  int gestisci() {
    char choice;
    while (1) {
      printMenu();
      scanf("%c", &choice);
      fflush(stdin);
      system("clear");
      if (choice == '3') {
        esciDalServer();
        return (0);
      } else if (choice == '2') {
        registrati();
      } else if (choice == '1') {
        if (tryLogin())
          play();
      } else
        printf("Input errato, inserire 1,2 o 3\n");
    }
  \end{lstlisting}
\section{Comunicazione durante la partita}
Una volta effettuato il login, il client potrà iniziare a giocare tramite la funzione play 
(Rigo 15 del \autoref{alg:clientPreLogin}  e rigo 12 del \autoref{alg:serverPreLogin}) che rappresentano il cuore della comunicazione tra client e server.\\

\lstlistoflistings
\end{document}