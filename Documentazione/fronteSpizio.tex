\documentclass[a4paper]{article}
\usepackage{amsfonts,amssymb,amstext,amsmath,amsthm,verbatim,times,cancel,epsfig} 
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel} 
\usepackage{setspace}
\usepackage{hyperref}
\usepackage{fancyvrb}
\usepackage{multicol}
\usepackage{listings}
\usepackage{caption}
\usepackage{geometry}
\usepackage{xcolor}
\definecolor{RoyalBlue}{cmyk}{1, 0.50, 0, 0}
\hypersetup{
    colorlinks=true, %set true if you want colored links
    linktoc=all,     %set to all if you want both sections and subsections linked
    linkcolor=black,  %choose some color if you want links to stand out
}
\geometry{
  bottom=10mm
}
\lstset{language=C,
    keywordstyle=\color{RoyalBlue},
    basicstyle=\scriptsize\ttfamily,
    commentstyle=\ttfamily\itshape\color{gray},
    stringstyle=\ttfamily,
    showstringspaces=false,
    breaklines=true,
    frameround=ffff,
    frame=single,
    rulecolor=\color{black},
    numbers = left,
    extendedchars=true,                      %questo rigo ed il successivo servono per usare le lettere à è ù nel codice
    literate={à}{{\'a}}1 {è}{{\'a}}1 {ù}{{\'u}}1 
}

\renewcommand\lstlistlistingname{Listati}
\renewcommand\lstlistingname{Listato}
\def\lstlistingautorefname{List.}
\captionsetup[lstlisting]{font={small,tt}}

\pagestyle{headings}
\begin{document} 

\setlength{\headsep}{20pt}
\setlength{\voffset}{-0.55in}
\setlength{\footskip}{10pt}
\begin{titlepage}
  \begin{center}
  
  % TO EDIT ACCORDINGLY TO...
  % -----------------------------------------------------------------------------------------------
  %
  
  % ... University Name
  {\bfseries\Huge Università degli Studi di Napoli\\}
  \vspace{2.54mm}
  {\bfseries\Huge Federico II\\}
  \vspace{5mm}
  
  % ... Logo
  \centerline{\mbox{\includegraphics[width=36mm]{fiilogo.png}}}
  
  % ... Departement
  \medskip
  {\bfseries\LARGE Dipartimento di Ingegneria Elettrica e\\}
  \vspace{2.54mm}
  {\bfseries\LARGE delle Tecnologie dell'Informazione\\}
  \vspace{5mm}
  
 
  
  % ... Degree Course
  {\large Corso di Laurea Triennale in Informatica\\}
  \vspace{2.5mm}
   % ... Degree Class
   {\emph{\large Classe n. L-31\\}}
   \vspace{2.54mm}
  % Change the name of Departement, Class and Cource in English?
  
  %
  % -----------------------------------------------------------------------------------------------
  %
  
  \vfill
  {\emph{\LARGE Progetto di sistemi operativi\\}}		% Thesis title
  \vspace{4mm}
  {\Large Traccia A\\}
  \vspace{4mm}
  
  \vfill
  
  \begin{multicols}{2}
    {\large Professore:\\}
    Finzi Alberto\
    \vspace{5mm}
    
    
      \vspace{5mm}
    
    {\large Candidati:\\}
    Turco Mario\\
    Matr. N8600/2503\\
    Longobardi Francesco\\
    Matr. N8600/2468\\
    \vspace{10mm}
  \end{multicols}
  
  \vfill
  
  % Fill the year
  {\large Anno Accademico\\ 2019/2020}
  
  \end{center}
  

\end{titlepage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
\clearpage\null\newpage

\pagenumbering{arabic}
\section{Istruzioni preliminari}
\subsection{Modalità di compilazione}
\paragraph{}
Il progetto è provvisto di un file makefile il quale è in grado di compilare autonomamente l'intero progetto.
Per utilizzare il makefile aprire la cartella del progetto tramite la console di sistema e digitare "make".\\
In alternativa è possibile compilare manualemente il client ed il server con i seguenti comandi:
\begin{Verbatim}[fontsize=\small]
    gcc -o server server.c boardUtility.c parser.c list.c -lpthread
    gcc -o client client.c boardUtility.c parser.c list.c -lpthread
\end{Verbatim}
\section{Guida all'uso }
\subsection{Server}
\paragraph{}
Una volta compilato il progetto è possibile avviare il server digitando da console il seguente comando
\begin{verbatim}
    ./server users
\end{verbatim}
L'identificativo \textit{users} ri riferisce al nome del file sul quale sarà salvata la lista degli utenti e delle loro credenziali.\\
È possibile scegliere un nome a piacimento per il file purchè esso sia diverso da \textit{Log}.
\subsection{Client}
\paragraph{}
Una volta compilato il progetto è possibile avviare il cient digitando da console il seguente comando:
\begin{verbatim}
    ./client ip porta
\end{verbatim}
Dove \textit{ip} andrà sostituito con l'ip o l'indirizzo URL del server e \textit{porta} andrà sostituito con la porta del server.\\
Una volta avviato il client comprarià il menu con le scelte 3 possibili: accedi, registrati ed esci.\\
Una volta effettuata la registrazione dell'utente è possibile effettuare l'accesso al programma al seguito del quale 
verranno mostrate sia la mappa sia le istruzioni di gioco.
\pagebreak
\section{Comunicazione tra client e server}
Di seguito verranno illustrate le modalità di comunicazione tra client e server.
\subsection{Configurazione del server}
Il socket del server viene configurato con famiglia di protoccoli PF\_NET, con tipo di trasmissione dati SOCK\_STREAM e con protocollo TCP. Mostriamo di seguito il codice sorgente:
\lstinputlisting[caption= {Configurazione indirizzo del server}, firstline={173}, lastline={181}]{../server.c}
\lstinputlisting[caption={Configurazione socket del server}, firstline={517}, lastline={534}]{../server.c}
È importante notare anche come il server riesca a gestire in modo concorrente più client tramite l'uso di un thread dedicato ad ogni client connesso. 
Una volta aver configurato il socket, il server si mette in ascolto per nuove connessioni in entrata ed, ogni volta che
viene stabilita una nuova connessione, il server avvia un thread per gestire tale connessione. Di seguito il relativo codice: 

\lstinputlisting[caption={Procedura di ascolto del server}, firstline={134}, lastline={172}]{../server.c}

In particolare al rigo 35 notiamo la creazione di un nuovo thread per gestire la connessione in entrata a cui passiamo il descrittore del client di cui si deve occupare.
Dal rigo 19 al rigo 31, estraiamo invece l'indirizzo ip del client per scriverlo sul file di log.

\subsection{Configurazione del client}
Il cliente invece viene configurato e si connette al server tramite la seguente funzione:
\lstinputlisting[caption={Configurazione e connessione del client}, firstline={65}, lastline={83}]{../client.c}

Si noti come al rigo 9 viene configurato il socket ed al rigo 13 viene invece effettuato il tentativo di connessione al server.\\
Al rigo 3 invece viene convertita la porta inserita in input (secondo argomento da riga di comando) dal tipo stringa al tipo corretto della porta (uint16\_t, unsigned long int).\\
Al rigo 4 notiamo invece la risoluzione dell'url da parte della funzione ipResolver che è riportata di seguito:
\lstinputlisting[caption={Risoluzione url del client}, firstline={250}, lastline={261}]{../client.c}
Al rigo 4, tramite l'url o l'indirizzo ip viene riempita la struttura hostent da cui poi possiamo estrarre l'indirizzo ip presente nel campo 
h\_addr\_list  che, in effetti, è un array che contiene i vari indirizzi ip associati a quell'host.\\
Infine, al rigo 11 ritorniamo il primo indirizzo convertito in Internet dot notation.
\pagebreak
\subsection{Comunicazione tra client e server}
La comunicazione tra client e server avviene tramite write e read sul socket.\\
Il comportamento del server e del client è determinato da particolari messaggi inviati e/o ricevuti che codificano, tramite interi o caratteri, la richiesta da parte del client
 di usufruire di un determinato servizio e la relativa risposta del server.
 \subsubsection{Esempio: la prima comunicazione}
 In particolare, una volta effettuata la connessione,il server attenderà un messaggio dal client per poter avviare 
 una delle tre possibili procedure, ovvero login, registrazione ed uscita ( rispettivamente codici: 1,2,3).\\
Di seguito sono riportate le realtive funzioni di gestione le quali vanno in esecuzione subito dopo aver stabilito la connessione
tra client e server.
\lstinputlisting[caption={Prima comunicazione del server}, label={alg:serverPreLogin}, firstline={228}, lastline={254}]{../server.c}
Si noti come il server riceva, al rigo 9, il messaggio codificato da parte del client e metta in esecuzione la funzione corrispondente.
\lstinputlisting[caption={Prima comunicazione del client}, firstline={84}, lastline={102}, label={alg:clientPreLogin} ]{../client.c}
\pagebreak
\section{Comunicazione durante la partita}
\paragraph{}
Una volta effettuato il login, il client potrà iniziare a giocare tramite la funzione play (Vedi \autoref{alg:playServer} e \autoref{alg:playclient})
che rappresentano il cuore della comunicazione tra client e server.
\subsection{Funzione core del server}
La funzione play del server consiste di un ciclo nel quale il server invia al client tre informazioni importanti:
\begin{itemize}
  \setlength\itemsep{0.2mm}
  \item La griglia di gioco (Rigo 32)
  \item Il player con le relative informazioni (Righi 34 a 37)
  \item Un messaggio che notifica al client se è iniziato un nuovo turno oppure no (Righi 52,57,62,71)
\end{itemize}
Dopodichè il thread del server rimane in attesa di ricevere l'input del client per spostare il giocatore sulla mappa tramite la relativa funzione. (Rigo 33) (Vedi \autoref{alg:sorgenteServer} Rigo 430 e \autoref{alg:boardUtility} Rigo 296, 331,367, 405 )
Oltre questo, la funzione play del server si occupa anche di generare la posizione del player appena entra in partita,
 generare la nuova posizione  (Righi 56 a 65) quando viene effettuato il cambio di mappa ed inviare il tempo rimanente 
 o la lista degli utente loggati al client su sua richiesta. 

\paragraph{}
È anche importante notare il seguente dettaglio implementativo: la griglia di gioco
è una matrice globale definita nel file del server che contiene tutti i player,
i punti di raccolta ed i pacchi,  mentre gli ostacoli sono contenuti in una seconda matrice globale del server. 
Ogni client però deve vedere soltanto gli ostacoli che ha già scoperto, 
per questo motivo ad ogni client non viene mandata direttamente la matrice di gioco, bensì, dai righi 22 a 24, 
inizializziamo una nuova matrice temporanea 
a cui aggiungiamo gli ostacoli già scoperti dal client (rigo 24) prima di mandarla al client stesso.
\\In questo modo ci assicuriamo che ogni client visualizzi soltanto gli ostacoli che ha già scoperto.


\lstinputlisting[caption={Funzione play del server}, label={alg:playServer}, firstline={255}, lastline={342}]{../server.c}

\subsection{Funzione core del client}
Dall'altro lato, la funzione play del client, è stata mantenuta il puù semplice possibile.
Lo scopo del client è unicamente quello di ricevere i dati forniti dal server, stampare la mappa di gioco e ed inviare un input al server che rappresenta la volontà del giocatore di muoversi, vedere la lista degli utenti, uscire o stampare il timer.
Unica eccezzione è il rigo 30  del client che non richiede la ricezione di ulteriori dati dal server: al rigo 23, infatti si avvia la procedura di disconnessione del client (Vedi \autoref{alg:sorgenteClient} rigo 59).

\lstinputlisting[caption={Funzione play del client}, label={alg:playclient}, firstline={111}, lastline={149}]{../client.c}
\pagebreak
\section{Dettagli implementativi degni di nota}
In questa sezione verranno trattati alcuni dettagli implementativi da noi giudicati interessanti in realzione a ciò che è stato studiato durante il corso di sistemi operativi.
\subsection{Timer}
\paragraph{}
Lo svolgimento della partite è legato al timer:  ogni round durerà un numero finito di secondi od oppure terminarà
quando un client raccoglierà il numero massimo di pacchi.
\paragraph{}
Subito dopo aver configurato il socket, il server inizia la procedura di avvio del timer (Vedi \autoref{alg:sorgenteServer} rigo 126 e 187) che farà partire un thread il quale si occuperà
di decrementare e resettare correttamente il timer (definito come variabile globale del server).
\lstinputlisting[caption={Funzione di gestione del timer}, firstline={478}, lastline={515}]{../server.c}
Analizzando il codice della funzione di modifica del timer si può notare un dettaglio abbastanza interessante: 
il thread che esegue la funzione del timer è legato ad un altro thread, ovvero quello della generazione di una nuova mappa.
Oltre ad un thread per gestire ogni client abbiamo quindi anche un altro thread che va a gestire il tempo ,
il quale attraverso un altro thread riesce a controllare la generazione della mappa e degli utenti allo scadere del tempo.
Si noti anche come, tramite il pthread\_join, il timer attenda la terminazione del secondo thread prima di resettare il timer e ricominciare il contro alla rovescia.
\footnote{Altro dettaglio meno importante, ma comunque degno di nota è il fatto che il timer non inizia il conto alla rovescia
se non c'è almeno un giocatore loggato, se questo non è stato posizionato sulla mappa e se questo non ha effettuato la prima mossa.
Al rigo 3 c'è anche da giustificare la variabile "cambiato" che non è nient'altro che un flag, il quale impedisce al server di stampare in stdout il valore del timer nel caso in cui esso sia stato appena resettato e non sia ancora iniziato il conto alla rovescia. Ciò evita che, prima che inizi il conto alla rovescia, il server continui a stampare il valore massimo del timer }
\paragraph{}
Per completezza si riporta anche la funzionione iniziale del thread di generazione mappa
\lstinputlisting[caption={Generazione nuova mappa e posizione players}, firstline={441}, lastline={453}]{../server.c}

\subsection{Gestione del file di Log}
\paragraph{}
Una delle funzionalità del server è quella di creare un file di log con varie informazioni durante la sua esecuzione.
Riteniamo l'implmentazione di questa funzione piuttosto interessante poichè, oltre ad essere una funzione gestita tramite un thread, fa uso sia di molte chiamate di sistema studiate durante il corso 
ed utilizza anche il mutex per risolvere eventuali race condition.
Riportiamo di seguito il codice:
\lstinputlisting[caption={Funzione di log}, firstline={683}, lastline={721}]{../server.c}
\paragraph{}
Analizzando il codice si può notare l'uso open per aprire in append o, in caso di assenza del file, di creare
il file di log ed i vari write per scrivere sul suddetto file; possiamo anche notare come la sezione critica, ovvero 
la scrittura su uno stesso file da parte di più thread, è gestita tramite un mutex.

\subsection{Modifica della mappa di gioco da parte di più thread}
La mappa di gioco è la stessa per tutti i player e c'è il rischio che lo spostamento dei player e/o la raccolta ed il deposito di pacchi possano provocare problemi
a causa della race condition che si viene a creare tra i thread. Tutto ciò è stato risolto con una serie di semplici accorgimenti implementativi.
Il primo accorgimento, e forse anche il più importante, è la funzione spostaPlayer mostrata qui di seguito.
\lstinputlisting[caption={Funzione spostaPlayer}, firstline={723}, lastline={737}]{../server.c}
Questa funzione rappresenta l'unico punto del programma che effettivamente modifica la matrice di gioco in seguito ad una richiesta di un client.
È possibile notare come l'intera funzione sia racchiusa in un mutex in modo da evitare che contemporaneamente più thread modifichino la mappa di gioco e 
quindi evita che due player si trovino nella stessa poszione.
\paragraph{}Il secondo accorgimento è stato quello di far in modo che un player possa raccogliere un pacco solo quando si trova nella poszione del pacco
("sia sovrapposto al pacco") e possa depositare un pacco solo nella posizione in cui il player stesso si trova ("deposita il pacco su se stesso").
\paragraph{}
Questi due accorgimenti, assieme, evitano qualsiasi tipo di conflitto tra i player: due player non potranno mai trovarsi nella stessa posizione
e, di conseguenza non potranno mai raccogliere lo stesso pacco o depositare due pacchi nella stessa posizione contemporaneamente.

\subsection{Gestione del login}
La gestione del login è il quarto ed ultimo dettagli implementativo giusdicato abbastanza interessante poichè
fa uso della system call system() per utilizzare le chiamate di sistema unix studiate durante la prima parte del corso.
Di seguito riportiamo il codice e la spiegazione
\lstinputlisting[caption={"Gestione del login 1"}, firstline={34}, lastline={52}]{../parser.c}
La funzione isRegistered tramite varie concatenazioni produce ed esegue il seguente comando 
\begin{verbatim}
  cat file | cut -d" " -f1|grep "^name$">tmp
\end{verbatim}
Ovvero andiamo a leggere la prima colonna (dove sono conservati tutti i nomi utente)
dal file degli utenti registrati, cerchiamo la stringa che combacia esattamente con name e la scriviamo sul
file temporaneo "tmp".\\ Dopodichè andiamo a verificare la dimensione del file tmp tramite la struttura stat: se
la dimensione è maggiore di 0 allora significa che è il nome esisteva nella lista dei client registrati ed è stato quindi trascritto in tmp
altrimenti significa che il nome non era presente nella lista dei player registrati.
A questo punto eliminiamo il file temporaneo e restituiamo il valore appropriato.
\paragraph{}\vspace{0.5mm}
\lstinputlisting[caption={"Gestione del login 2"}, firstline={53}, lastline={75}]{../parser.c}
La funziona validateLogin invece, tramite concatenazioni successive crea ed esegue il seguente comando:
\begin{verbatim}
  cat file | grep "^nome password$">tmp
\end{verbatim}
Verificando se la coppia nome password sia presente nel file degli utenti registrati, trascrivendola sul file tmp
Ancora una volta si va a verificare tramite la struttura stat se è stato trascritto qualcosa oppure no, ritornando 
il valore appropriato.
\appendix
\pagebreak
\section{Codici sorgente}
Di seguito sono riportati tutti i codici sorgenti integrali del progetto.
\subsection{Codice sorgente del client}
\lstinputlisting[caption ={ Codice sorgente del client}, label={alg:sorgenteClient}]{../client.c}
\subsection{Codice sorgente del server}
\lstinputlisting[caption ={Codice sorgente del server}, label={alg:sorgenteServer} ]{../server.c}
\subsection{Codice sorgente boardUtility}
\lstinputlisting[caption ={Codice header utility del gioco 1} ]{../boardUtility.h}
\lstinputlisting[caption ={Codice sorgente utility del gioco 1}, label={alg:boardUtility} ]{../boardUtility.c}
\subsection{Codice sorgente list}
\lstinputlisting[caption ={Codice header utility del gioco 2} ]{../list.h}
\lstinputlisting[caption ={Codice sorgente utility del gioco 2}, label={alg:list} ]{../list.c}
\subsection{Codice sorgente parser}
\lstinputlisting[caption ={Codice header utility del gioco 3} ]{../parser.h}
\lstinputlisting[caption ={Codice sorgente utility del gioco 3}, label={alg:parser} ]{../parser.c}
\pagebreak
\lstlistoflistings


\end{document}